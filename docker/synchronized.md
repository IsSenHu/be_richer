## synchronized

> 四种锁状态的升级
>
> 无锁 =>偏向锁=>轻量级锁=>重量级锁
>
> 是非公平锁（非公平锁即无法保证锁的获取是按照请求锁的顺序进行的）

### Java对象头

​		HotSpot虚拟机的实现中，对象头主要包括两部分数据：Mark Word（标记字段）、元数据指针、（如果是数组）数组的长度。	

​		`Mark Word`

  		1. 默认存储对象的HashCode；
  		2. 分代年龄；
  		3. 锁标志位信息。

​      这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。

### Monitor

​		Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。

​		Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局可用列表。每个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

### 无锁

​		无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只能有一个线程能修改成功。无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。

### 偏向锁

​		偏向锁是指当一段同步代码块一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。

​		当一个线程访问同步代码块并获取锁的时候，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块的时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

​		关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。

​		偏向锁在 JDK 6 及之后版本的 JVM 里是默认启用的。可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。

### 轻量级锁

​		轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。

- 关闭偏向锁功能时；
- 由于多个线程竞争偏向锁。

​      在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机将首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后将对象头中的 Mark Word 复制到锁记录中。

​		拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向对象的 Mark Word。

​		如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

​		如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

​		若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。

​		另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。

### 重量级锁

​		重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。

​		简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。

## AQS

> 所谓AQS，指的是AbstractQueuedSynchronizer。
>
> ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的。

## synchronized和lock的区别

> Synchronized是关键字，内置语言实现，Lock是接口。
>
> Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。
>
> ReentrantLock等待可中断（持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况，通过lock.lockInterruptibly()来实现这个机制）。
>
> ReentrantLock可以指定为公平锁，公平锁性能不是很好。
>
> Lock可以使用读锁提高多线程读效率。
>
> 锁绑定多个条件（一个ReentrantLock对象可以同时绑定对个对象，Condition）。
>
> ReentrantLock性能要好一点，因为避免了使线程进入内核态的阻塞状态。

## Volatile关键字的底层原理

> 添加内存屏障

*内存屏障*

1. 阻止屏障两侧的指令重排序；
2. **强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。**强制把更新后的数据写回主内存。

Load Barrier

Store Barrier

## 线程池的线程数该如何设置

> n：CPU核数
>
> y：阻塞系数
>
> CPU密集型	n + 1
>
> IO密集型	n / (1 - y)
>
> 具体如何设置可以在开发的时候进行调试，看看设置为多少是最好的。

## 说一下单例场景为什么要使用DCL

> 因为可能有的类的创建是比较耗时而且可能在系统的运行中不会被使用到，所以采用DCL，这种模式是懒汉模式，可以减少不必要的系统资源的浪费。
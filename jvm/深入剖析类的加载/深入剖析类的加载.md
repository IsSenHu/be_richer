## 深入了解类的加载、连接与初始化

[TOC]

1. 在**Java**代码中，类型的加载、连接与初始化过程都是**在程序运行期间完成**的
2. 提供了更大的灵活性，增加了更多的可能性

### 一、Java虚拟机与程序的生命周期

**在如下几种情况下，**Java**虚拟机将结束生命周期，如图所示：**

<img src="https://studysssmd.oss-cn-chengdu.aliyuncs.com/jvm/class_load/5.png" alt="QQ截图20200120142612" style="zoom:80%;" />

### 二、类的加载、连接与初始化

**类的加载、连接与初始化流程从上至下如图所示：**

<img src="https://studysssmd.oss-cn-chengdu.aliyuncs.com/jvm/class_load/6.png" alt="QQ截图20200120143621" style="zoom:80%;" />

**此外还有类实例化的流程如下：**

1. 为新的对象分配内存
2. 为实例变量赋默认值
3. 为实例变量赋正确的初始值

**Java**编译器为它编译的每一个类都至少生成一个实例初始化化方法，在**Java**的**class**文件中，这个实例初始化方法被称为"&lt;init&gt;"。针对源代码中每一个类的构造方法，**Java**编译器都产生一个"&lt;init&gt;"方法。

**总流程如下图所示：**

![IMG_6001(20200120-090447)](https://studysssmd.oss-cn-chengdu.aliyuncs.com/jvm/class_load/1.PNG)

**运行HelloApp,main()方法的类加载、连接与初始化调用流程如下：**

<img src="https://studysssmd.oss-cn-chengdu.aliyuncs.com/jvm/class_load/2.PNG" alt="IMG_6002" style="zoom:67%;" />

### 三、类的加载详解

**加载：就是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。**

- 类的加载的最终产品是位于内存中的**Class对象**
- **Class**对象封装了类在方法区内的数据结构，并且向**Java**程序员提供了访问方法区内的数据结构的接口
- 加载**.class文件的方式**
  1. 从本地系统中直接加载
  2. 通过网络下载**.class**文件
  3. 从**zip**，**jar**等归档文件中加载**.class**文件
  4. 从专有数据库中提取**.class**文件
  5. 将**Java**源文件动态编译为**.class**文件

**类的加载器：有两种类型的类加载器**

- **Java**虚拟机自带的类加载器
  1. <u>根类加载器（Bootstrap）</u>
  2. <u>扩展类加载器（Extension）</u>
  3. <u>系统（应用）类加载器（System）</u>
- 用户自定义的类加载器
  1. **java.lang.ClassLoader**的子类
  2. 用户可以定制类的加载方式

**类加载器并不是要等到某个类被 “首次主动使用” 时再加载它**

#### JVM规范

- **JVM**规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了**.class**文件缺失或存在错误，类加载器必须在**程序首次主动**使用该类时才报告错误（**LinkageError**错误）
- 如果这个类一直没有被程序主动使用，那么**类加载器就不会报告错误**

### 四、类的连接详解

**类被加载后，就进入连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行环境中去。**

- 类的验证的内容
  - 类文件的结构检查
  - 语义检查
  - 字节码验证
  - 二进制兼容性的验证

- 在准备阶段，Java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0。

  ```java
  public class Sample {
      private static int a = 1;
      public static long b;
      
      static {
          b = 2;
      }
  }
  ```

### 五、类的初始化详解

**类的加载和连接一定会执行，初始化却不一定，那什么时候进行初始化呢？**

- **Java**程序对类的使用方式可分为**主动使用**和**被动使用**

- 所有的**Java**虚拟机必须在每个类或接口被**Java**程序“**首次主动使用时**”才初始化它们

  - 主动使用（7种）
    1. 创建类的实例
    2. 访问某个类或接口的静态变量，或者对该静态变量赋值
    3. 调用类的静态方法
    4. 反射（如**Class.forName("com.test.Test")**）
    5. 初始化一个类的子类
    6. **Java**虚拟机启动时被标明为启动类的类
    7. **JDK1.7**开始提供动态语言支持：**java.lang.invoke.MethodHandle**实例的解析结果**REF_getStatic**、**REF_putStatic**、**REF_invokeStatic**句柄对应的类没有初始化，则初始化

  - 除了以上七种情况，其他使用**Java**类的方法都被看作对类的**被动使用**，都不会导致类的初始化

- 类的初始化步骤
  1. 假如这个类还没有被加载和连接，那就先进行加载和连接
  2. 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
  3. 假如类中存在初始化语句，那就**依次执行**这些初始化语句

- 接口初始化规则

  1. 当**Java**虚拟机初始化一个类时，要求它的所有父类都已被初始化，但是这条规则并不适用于接口

     - 在初始化一个类时，并不会先初始化它所实现的接口
     - 在初始化一个接口时，并不会初始化它的父接口

     因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。

- 调用**ClassLoader**类的**loadClass**方法加载一个类，并不是对类的主动使用，不会导致类的初始化

#### *下面举一些例子*

**1.只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用，例如下面的代码：**

```java
public class MyTest1 {
    public static void main(String[] args) {
        // 对于静态字段来说，只有直接定义了该字段的类才会被初始化；
        System.out.println(MyChild1.str);
        // 输出
        // MyParent1 static block
        // hello world
        // 输出的结果说明了只初始化了MyParent1
    }
}

class MyParent1 {
    public static String str = "hello world";

    static {
        System.out.println("MyParent1 static block");
    }
}

class MyChild1 extends MyParent1 {
    public static String str2 = "welcome";

    static {
        System.out.println("MyChild1 static block");
    }
}
```

**2.常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上，调用类并没有直接引入到定义常量的类，因此并不会触发定义常量的类的初始化，例如下面的代码：**

```java
public class MyTest2 {
    public static void main(String[] args) {
        // 常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，
        // 本质上，调用类并没有直接引入到定义常量的类，因此并不会触发定义常量的类的初始化
        // 注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关		    // 系了，甚至，我们可以将MyParent2的class问价删除
        System.out.println(MyParent2.str);
        // 输出
        // hello world
        // 输出的结果说明了未初始化MyParent2
    }
}

class MyParent2 {
    public static final String str = "hello world";
    static {
        System.out.println("MyParent2 static block");
    }
}
```

**运行javap -c MyTest2 得到结果如下：**

```java
public class com.gapache.commons.jvm.classloader.MyTest2 {
  public com.gapache.commons.jvm.classloader.MyTest2();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #4                  // String hello world
       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
}
```

会看到一个**ldc**的助记符，表示将int，float或String类型的常量值从常量池中推送至栈顶，所以在编译的时候就已经优化好了，并不需要去主动使用MyParent2。

**3.当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化，例如下面的代码：**

```java
public class MyTest3 {
    public static void main(String[] args) {
        // 当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中
        // 这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化
        System.out.println(MyParent3.str);
        // 输出
        // MyParent3 static code
        // d71fd705-5a12-4655-bf12-22cd1b7f6392
        // 说明初始化了MyParent3
    }
}

class MyParent3 {
    public static final String str = UUID.randomUUID().toString();
    static {
        System.out.println("MyParent3 static code");
    }
}
```

**4.由它作为数组元素类型的数组进行初始化，并不会导致它的初始化，这个数组实例的类是由JVM在运行期动态生成的。动态生成的类，其父类型就是Object。对于数组来说，JavaDoc经常将构成数组的元素Component，实际上就是将数组降低一个维度后的类型，例如下面的代码：**

```java
public class MyTest4 {
    public static void main(String[] args) {
        // 对于数组实例来说，其类型是由JVM在运行期动态生成的。动态生成的类型，其父类型就是Object
        // 对于数组来说，JavaDoc经常将构成数组的元素Component，实际上就是将数组降低一个维度后的类型
        MyParent4[] myParent4s = new MyParent4[1];
        System.out.println(myParent4s.getClass());
        // class [Lcom.gapache.commons.jvm.classloader.MyParent4;
        MyParent4[][] myParent4s1 = new MyParent4[1][1];
        System.out.println(myParent4s1.getClass());
        // class [[Lcom.gapache.commons.jvm.classloader.MyParent4;
        System.out.println(myParent4s.getClass().getSuperclass());
        // class java.lang.Object
        System.out.println(myParent4s1.getClass().getSuperclass());
        // class java.lang.Object
        System.out.println("======================");
        int[] ints = new int[1];
        System.out.println(ints.getClass());
        // class [I
        System.out.println(ints.getClass().getSuperclass());
        // class java.lang.Object
    }
}

class MyParent4 {
    static {
        // 上面并没有输出这段，说明数组实例化时不会初始化该类
        System.out.println("MyParent4 static code");
    }
}
```

**5.使用类的静态方法 表示对类的主动使用会进行初始化，并且从上往下进行初始化，例如下面的代码：**

```java
public class MyTest6 {
    public static void main(String[] args) {
        // 使用类的静态方法 表示对类的主动使用 会进行初始化
        Singleton instance = Singleton.getInstance();
        // 从上往下进行初始化
        System.out.println("counter1: " + Singleton.counter1);
        System.out.println("counter2: " + Singleton.counter2);
        // counter1: 1
        // counter2: 0
    }
}

class Singleton {
    public static int counter1;

    private static Singleton singleton = new Singleton();

    public Singleton() {
        counter1++;
        // 准备阶段的重要意义
        counter2++;
    }

    public static int counter2 = 0;

    public static Singleton getInstance() {
        return singleton;
    }
}
```

**6.在初始化一个类时，并不会先初始化它所实现的接口，例如下面的代码：**

```java
public class MyTest5 {
    public static void main(String[] args) {
        // 在初始化一个类时，并不会先初始化它所实现的接口
        System.out.println(MyChild5.b);
        // 5
    }
}

interface MyParent5 {
    int a = new Random().nextInt();
    Thread thread = new Thread() {
        // 每个实例创建时都会执行一次
        {
            System.out.println("MyParent5 invoked");
        }
    };
}

class MyChild5 implements MyParent5 {
    public static int b = 5;
}
```

**7.初始化一个接口时，并不要求其父接口都完成了初始化，例如下面的代码：**

```java
public class MyTest7 {
    public static void main(String[] args) {
        // 初始化一个接口时，并不要求其父接口都完成了初始化
        System.out.println(MyParent7.thread);
        // MyParent5 invoked
        // Thread[Thread-0,5,main]
    }
}

interface MyGradpa {
    int a = new Random().nextInt();
    Thread thread = new Thread() {
        {
            System.out.println("MyGradpa invoked");
        }
    };
}

interface MyParent7 extends MyGradpa {
    Thread thread = new Thread() {
        {
            System.out.println("MyParent5 invoked");
        }
    };
}
```

**8.但是不代表一定不初始化父接口，在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化，例如下面的代码：**

```java
public class MyTest8 {
    public static void main(String[] args) {
        // 但是不代表一定不初始化父接口，在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化
        System.out.println(MyParent8.thread);
        // MyParent5 invoked
        // MyGradpa invoked
        // Thread[Thread-1,5,main]
        // Thread[Thread-0,5,main]
    }
}

interface MyGradpa8 {
    Thread threadGradpa = new Thread() {
        {
            System.out.println("MyGradpa invoked");
        }
    };
}

interface MyParent8 extends MyGradpa8 {
    Thread thread = new Thread() {
        {
            System.out.println("MyParent5 invoked");
            System.out.println(threadGradpa);
        }
    };
}
```

### 六、类加载器详解

**类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用[父亲委托机制]()，这种机制能更好地保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。流程如下：**

![QQ截图20200120135600](https://studysssmd.oss-cn-chengdu.aliyuncs.com/jvm/class_load/3.png)

**Java虚拟机自带了以下几种加载器**

- 根（Bootstrap）类加载器：该加载器没有父加载器。它负责加载虚拟机的核心库，如java.lang.*等。根类加载器从系统属性**sun.boot.class.path**所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。
- 扩展（Extension）类加载器：它的父加载器为根类加载器。它从**java.ext.dirs**系统属性所指定的目录中加载类库，或者从JDK的安装目录的**jre\lib\ext**子目录（扩展目录）下加载类库，如果把用户创建的**JAR**文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader的子类。
- 系统（System）类加载器：也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量**classpath**或者系统属性**java.class.path**所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.ClassLoader的子类。

**除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。**

![QQ截图20200120142036](https://studysssmd.oss-cn-chengdu.aliyuncs.com/jvm/class_load/4.png)

### 七、本节出现的助记符

| 助记符号               | 作用                                                         |
| :--------------------- | ------------------------------------------------------------ |
| getStatic              | 访问类的静态域                                               |
| putStatic              | 给类的静态域赋值                                             |
| invokeStatic           | 调用命名类中的静态方法                                       |
| ldc                    | 表示将int，float或String类型的常量值从常量池中推送至栈顶     |
| bipush                 | 表示将单字节（-128 ~ 127）的常量值推送至栈顶                 |
| sipush                 | 表示将一个短整型常量值（-32768 ~ 32767）推送至栈顶           |
| iconst_i（-1 ≤ i ≤ 5） | 表示将int类型（-1 ~ 5）推送至栈顶                            |
| anewarray              | 表示创建一个引用类型的（如类、接口、数组）数组，并将其引用值压入栈顶 |
| newarray               | 表示创建一个指定的原始类型（int、float、char等）数组，并将其引用值压入栈顶 |

### 八、本节出现的JVM参数

| 参数                   |                         |
| ---------------------- | ----------------------- |
| -XX:+<option>          | 表示开启option选项      |
| -XX:-<option>          | 表示关闭option选项      |
| -XX:<option>=<value>   | 表示给option赋值为value |
| -XX:+TraceClassLoading | 跟踪类的加载            |


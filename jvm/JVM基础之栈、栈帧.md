## JVM基础之栈、栈帧

[TOC]

### 一、栈（虚拟机栈VM Stack）

#### 1.1 关于栈的一些说明

1. 栈又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端又称为栈顶，相对地把另一端称为栈底，其特性是先进后出。

2. 栈是运行时的单位，在整个JVM的内存之中，栈内存是一个非常重要的概念。栈内存是线程私有的，其生命周期和线程相同。

3. 栈里面存的都是与当前线程相关的信息，包括：局部变量（方法参数列表中的变量，方法体中的基本数据类型的变量和引用数据类型的引用）、程序运行状态、方法返回地址等。成员变量和对象本身不存放在栈中。

4. 栈的变量随着变量作用域的结束而释放，不需要JVM垃圾回收机制回收。

5. 栈不是全局共享的，每个线程创建一个栈，该线程不能访问其他线程对应的栈的数据。

6. 栈内存的大小在编译期就确定了的。

7. 虚拟机栈图示：栈中保存的是一个又一个栈帧。

   ![](https://www.pianshen.com/images/817/ba0bafc51d52b47415644f62051e4aa9.png)

#### 1.2 栈和方法

栈描述的是Java方法执行的内存模型，执行一个方法时会产生一个栈帧，随后将其保存到栈的顶部，方法执行完毕后会自动将此方法对应的栈帧自顶部移除（即出栈），当前方法（当前正在执行的方法？）的栈帧必然在当前线程对应的栈的顶部。

栈帧的出栈与入栈图示：

![](https://www.pianshen.com/images/493/2e165b69bbd1472f9be1c125e83a3665.png)

注：一个栈帧对应一个未运行完的函数。当某一个函数被调用一次时，就会产生一个栈帧（记录着该函数的相关信息）并入栈。当该函数运行完毕之后，其对应的栈帧就会出栈。

注：函数的一次调用就会产生一个对应的栈帧，而不是一个函数本身对应一个栈帧。如：递归调用就可能会产生无数个栈帧。

#### 1.3 栈的溢出

从栈的结构可知，如果栈帧的数量过多（n多次调用方法）或某个（些）栈帧过大会导致栈溢出引发SOE（Stack Overflow Error），这两种溢出方式如图所示：

![](https://www.pianshen.com/images/814/ebedd4aa58f5da89cfe71b4f780fe446.png)

注：果运行虚拟机栈动态扩展，那么当内存不足时，会导致OOM（OutOfMemmoryError）。

栈帧数量过多导致栈溢出演示，我们使用递归来演示，代码如下所示：

```java
public class StackOverflowError {

    private static void test() {
      	// 当执行test()方法的时候，将会无限的递归调用test()方法
        test();
    }

    public static void main(String[] args) {
        test();
    }
}
```

执行main方法结果：

```java
Exception in thread "main" java.lang.StackOverflowError
	at com.gapache.commons.jvm.memory.StackOverflowError.test(StackOverflowError.java:10)
	at com.gapache.commons.jvm.memory.StackOverflowError.test(StackOverflowError.java:10)
	at com.gapache.commons.jvm.memory.StackOverflowError.test(StackOverflowError.java:10)
	at com.gapache.commons.jvm.memory.StackOverflowError.test(StackOverflowError.java:10)
	at com.gapache.commons.jvm.memory.StackOverflowError.test(StackOverflowError.java:10)
	at com.gapache.commons.jvm.memory.StackOverflowError.test(StackOverflowError.java:10)
  .
  .
  .
```

#### 1.4  栈的优缺点

优点：

- 栈帧内存数据共享：栈帧之间的数据不能共享，但是同一个栈帧内的数据可以共享的，这样设计是为了减小内存消耗。例如：int a = 1, int b= 1时，前面定义了a=1，a和1都在栈内存内，如果再定义一个b=1，此时将b放入栈内存，然后查找栈内存中是否有1，如果有则b指向1。如果再给b赋值2，则在栈内存中查找是否有2，如果没有就在栈内存中放一个2，然后b指向2。也就是如果常量在栈内存中，就将变量指向该常量，如果没有就在该栈内存增加一个该常量，并将变量指向该常量。
- 存取速度比堆要快：仅次于寄存器。速度快之一是栈在编译期间就申请好了内存空间，所以在运行时不需要申请内存大小，节约了时间，其二是栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。其三是访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。

缺点：

- 存在栈的数据大小和生存期必须是确定的，缺乏灵活性。当栈在运行执行程序时，发现栈内存不够，不会动态的去申请内存，以至于导致程序报错，所以灵活性较差。

#### 1.5 栈上分配

JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。

栈上分配的一个技术基础是进行逃逸分析，逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。另一个是标量替换，允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。

只能在server模式下才能启用逃逸分析，参数-XX:DoEscapeAnalysis启用逃逸分析，参数              -XX:+EliminateAllocations开启标量替换（默认打开）。在JDK 6u23版本之后，HotSpot中默认就开启了逃逸分析，可以通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果

因为栈的空间比较小，所以栈上分配的对象只能是小对象（1M以下），大对象和逃逸对象是不能进行栈上分配的。

[逃离分析和标量替换](https://blog.csdn.net/w372426096/article/details/80938788)

[对象并不一定都是在堆上分配内存的](https://blog.csdn.net/w372426096/article/details/80333657)

### 二、栈帧(Stack Frame)

#### 2.1   栈帧简述

栈帧就是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈的组成元素。调用一次方法（无论是不是调用的同一个方法）就会产生一个栈帧。

#### 2.2 栈帧中主要包含的数据

栈帧中主要包含的数据有：

- 局部变量表（Local Variable Table）
- 操作数栈（Operand Stack）
- 返回地址（Return Address）
- 动态链接（Dynamic Linking）
- 指向运行时常量池的引用
- ...

#### 2.3 局部变量表

局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表以变量槽（solt）为最小单位，一个变量槽最大只允许保存四字节（即：32位）长度的变量，如果超过32位，则会开辟两个连续的solt。局部变量存储的数据类型如下图所示：

![](http://studysssmd.oss-cn-chengdu.aliyuncs.com/jvm/memory/QQ20200418-152903.png)

注：在.java编译为.class文件时，就在方法表的Code属性的max_locals数据项中确定了方法所需要分配的局部
变量表的最大容量。

#### 2.4 操作数栈（Operand Stack）

表达式计算在操作数栈中完成。当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈和出栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。

注：在概念模型里面，虚拟机栈中的栈帧之间是完全相互独立的。但是在大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面的栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以公用一部分数据，无需进行额外的参数复制传递，重叠的过程如图所示：

![](https://www.pianshen.com/images/761/e1edbfd5c20f17fa49ab2cfedf0b76a9.png)

#### 2.5 返回地址

方法执行完（不论是正常执行还是发生了异常）后需要返回到方法被调用的位置，程序才能继续执行，方法可能需要在栈帧中保存一些信息，用来帮助恢复上层方法的执行状态。

一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理表来决定的，栈帧中一般不会保存这部分信息。

方法的退出过程实际上就相当于把当前栈帧出栈，因此退出时可能执行的操作有：

1. 恢复上层方法的局部变量表和操作数栈。
2. 把返回值（如果有的话）压入调用者栈帧的操作数栈中。
3. 调整PC计数器的值以指向方法调用指令后面的一条指令。
4. ......

#### 2.6 动态链接（Dynamic Linking）

在说明什么是动态连接之前先看看方法的大概调用过程，首先在虚拟机运行的时候，运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用，如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用,然后通过直接引用才可以访问到真正的方法。这时候就有一点需要注意，如果符号引用是在**类加载阶段或者第一次使用的时候转化为直接引用**，那么这种转化称为**静态解析**，如果是在**运行期间转化为直接引用**，那么这种转化就称为**动态链接**。

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。

#### 2.7 指向运行时常量池的引用

当前方法所属的类的运行时常量池的引用，引用其他的常量类或者使用String池中的字符串。